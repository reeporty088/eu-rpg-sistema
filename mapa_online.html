<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Mundi - RPG</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; }
        
        /* UI DO EDITOR */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 320px; height: 100%;
            background: rgba(30, 30, 30, 0.95); border-right: 2px solid #444;
            padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; gap: 8px;
            z-index: 10; box-shadow: 5px 0 15px rgba(0,0,0,0.5);
            transition: transform 0.3s;
            overflow-y: auto;
        }

        body.viewer-mode #ui-layer { transform: translateX(-350px); }

        canvas { display: block; background: #111; cursor: default; }
        
        h2 { margin: 5px 0 5px 0; color: #ffaa00; text-transform: uppercase; font-size: 14px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        label { font-size: 11px; color: #aaa; display: block; margin-bottom: 2px; margin-top: 5px; }
        input[type="range"], input[type="text"], input[type="color"] { width: 100%; box-sizing: border-box; margin-bottom: 5px; background: #222; border: 1px solid #555; color: white; padding: 4px; border-radius: 4px; }
        
        .btn { background: #444; color: white; border: 1px solid #666; padding: 8px; cursor: pointer; width: 100%; margin-bottom: 5px; font-weight: bold; border-radius: 4px; transition: 0.2s; font-size: 12px; }
        .btn:hover { background: #666; }
        .btn-save { background: #2e7d32; border-color: #4caf50; }
        
        .tools-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .tool-btn { flex: 1; padding: 10px; font-size: 18px; background: #222; border: 1px solid #555; cursor: pointer; border-radius: 5px; }
        .tool-btn.active { background: #ffaa00; border-color: white; color: black; }

        .palette { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 10px; max-height: 200px; overflow-y: auto; padding-right: 5px; }
        .swatch { width: 100%; aspect-ratio: 1; border: 2px solid #555; cursor: pointer; transition: 0.2s; position: relative; border-radius: 4px; display:flex; align-items:center; justify-content:center; background: #222; }
        .swatch:hover { border-color: white; transform: scale(1.1); z-index: 2; }
        .swatch.selected { border-color: #ffaa00; box-shadow: 0 0 10px #ffaa00; z-index: 2; }
        
        .status-led { width: 10px; height: 10px; border-radius: 50%; background: #444; display: inline-block; margin-right: 5px; }
        .status-led.on { background: #00ff00; box-shadow: 0 0 5px #00ff00; }
        .status-led.busy { background: #ffaa00; animation: blink 0.5s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; pointer-events: none; opacity: 0; transition: 0.5s; }
        .loading-overlay.active { opacity: 1; pointer-events: all; }

        #viewer-msg { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 20px; border: 1px solid #ffaa00; color: #ffaa00; font-weight: bold; display: none; z-index: 5; }
        body.viewer-mode #viewer-msg { display: block; }
        
        .input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .input-group input { margin-bottom: 0; }
        .input-group button { width: 40px; margin-bottom: 0; display: flex; align-items: center; justify-content: center; }

        .tool-controls { display: none; background: #222; padding: 10px; border-radius: 5px; border: 1px solid #555; margin-bottom: 10px; }
        .tool-controls.visible { display: block; }
    </style>
</head>
<body>

    <div id="viewer-msg">MODO VISUALIZADOR (Somente Leitura)</div>
    <div class="loading-overlay" id="loader">Carregando Mapa...</div>

    <div id="ui-layer">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>EDITOR DE MAPA</h2>
            <div title="Status da Conex√£o"><span id="db-led" class="status-led"></span></div>
        </div>

        <div class="tools-row">
            <button class="tool-btn active" id="btnBrush" onclick="setTool('brush')" title="Pintar (B)">üñåÔ∏è</button>
            <button class="tool-btn" id="btnGen" onclick="setTool('generator')" title="Gerador Procedural (G)">ü™Ñ</button>
            <button class="tool-btn" id="btnBorder" onclick="setTool('border')" title="Fronteira (F)">‚úèÔ∏è</button>
            <button class="tool-btn" id="btnHand" onclick="setTool('hand')" title="Mover (H)">‚úã</button>
        </div>

        <div id="gen-controls" class="tool-controls">
            <label style="margin-top:0; color:#4caf50;">Gerador de Bioma</label>
            <label>Raio do Pincel: <span id="genRadiusVal">3</span></label>
            <input type="range" id="genRadius" min="1" max="10" value="3" oninput="document.getElementById('genRadiusVal').innerText=this.value">
            <label>Densidade: <span id="genDensityVal">80%</span></label>
            <input type="range" id="genDensity" min="10" max="100" value="80" oninput="document.getElementById('genDensityVal').innerText=this.value+'%'">
            <small style="color:#aaa; font-size:10px;">Selecione um terreno abaixo e clique no mapa para preencher a √°rea.</small>
        </div>

        <div id="border-controls" class="tool-controls">
            <label style="margin-top:0; color:#ffaa00;">Ferramenta de Fronteira</label>
            <label>Cor da Linha</label>
            <input type="color" id="borderColor" value="#ff0000">
            <label>Espessura</label>
            <input type="range" id="borderWidth" min="2" max="10" value="4">
        </div>

        <h2>Configura√ß√£o Global</h2>
        <label>URL da Imagem de Fundo</label>
        <div class="input-group">
            <input type="text" id="bgUrlInput" placeholder="Link direto...">
            <button class="btn" onclick="updateBgFromUrl(document.getElementById('bgUrlInput').value)" title="Carregar">OK</button>
        </div>

        <label>Tamanho Hex√°gono</label>
        <input type="range" id="hexSize" min="10" max="150" value="30">
        
        <label>Opacidade da Grade</label>
        <input type="range" id="gridOpacity" min="0" max="1" step="0.1" value="0.3">
        
        <label>Opacidade dos Terrenos (Hex)</label>
        <input type="range" id="hexOpacity" min="0" max="1" step="0.1" value="1">
        
        <label>Opacidade do Fundo (Imagem)</label>
        <input type="range" id="bgOpacity" min="0" max="1" step="0.1" value="1">

        <hr style="border:0; border-top:1px solid #444; width:100%;">
        
        <h2>Terrenos (Biomas)</h2>
        <div class="palette" id="palette"></div>

        <button class="btn btn-save" onclick="saveToCloud()">‚òÅÔ∏è SALVAR NO CLOUD</button>
        <button class="btn" style="background:#c62828;" onclick="clearHexes()">üóëÔ∏è Limpar Tudo</button>
        
        <div style="margin-top:auto; font-size:11px; color:#666; text-align:center;">
            Link Visualizador:<br>
            <a href="#" id="viewLink" style="color:#4fc3f7; word-break:break-all;" target="_blank">...</a>
        </div>
    </div>

    <canvas id="mapCanvas"></canvas>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getDatabase, ref, update, onValue } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCvxxwfsonP5a45nbcz34cxYhXaWBZVhwQ",
        authDomain: "ed-rpg---sistema-de-fichas.firebaseapp.com",
        databaseURL: "https://ed-rpg---sistema-de-fichas-default-rtdb.firebaseio.com",
        projectId: "ed-rpg---sistema-de-fichas",
        storageBucket: "ed-rpg---sistema-de-fichas.firebasestorage.app",
        messagingSenderId: "350999444010",
        appId: "1:350999444010:web:d89f31d13e449b8fbfa153"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const urlParams = new URLSearchParams(window.location.search);
    const MODE = urlParams.get('mode') === 'view' ? 'VIEW' : 'EDIT';
    const MAP_ID = 'mapa_mundi_principal';

    if (MODE === 'VIEW') document.body.classList.add('viewer-mode');
    else {
        const baseUrl = window.location.href.split('?')[0];
        document.getElementById('viewLink').href = `${baseUrl}?mode=view`;
        document.getElementById('viewLink').innerText = "Clique para abrir modo Visualizador";
    }

    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const led = document.getElementById('db-led');

    let camera = { x: 0, y: 0, zoom: 1 };
    
    // Ferramentas
    let activeTool = 'brush'; 
    let isSpacePressed = false;
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };
    
    // Dados
    let bgImage = null;
    let bgImageUrl = "";
    let hexMap = {}; 
    let borderMap = {}; 
    let hexRadius = 30;
    let gridOpacity = 0.3;
    let hexOpacity = 1.0; // Nova Opacidade
    let bgOpacity = 1.0;  // Nova Opacidade

    // TERRENOS
    const TERRAINS = {
        'void': { color: 'transparent', icon: '‚ùå', label: 'Apagar' },
        'grass': { color: '#2e7d32', icon: 'üå±', label: 'Plan√≠cie' },
        'forest': { color: '#1b5e20', icon: 'üå≤', label: 'Floresta' },
        'ocean': { color: '#1a237e', icon: 'üåä', label: 'Oceano' },
        'mountain': { color: '#5d4037', icon: '‚õ∞Ô∏è', label: 'Montanha' },
        'desert': { color: '#fbc02d', icon: 'üåµ', label: 'Deserto' },
        'snow': { color: '#eceff1', icon: '‚ùÑÔ∏è', label: 'Neve' },
        'swamp': { color: '#2e3828', icon: 'üê∏', label: 'P√¢ntano' },
        'coast': { color: '#4fc3f7', icon: 'üíß', label: 'Costa' },
        'city': { color: '#9e9e9e', icon: 'üè∞', label: 'Cidade' },
        'village': { color: '#795548', icon: 'üè†', label: 'Vila' },
        'ruin': { color: '#000000', icon: 'üíÄ', label: 'Ru√≠na' },
        'tower': { color: '#5c6bc0', icon: 'üóº', label: 'Torre' },
        'cave': { color: '#3e2723', icon: 'ü¶á', label: 'Caverna' },
        'road': { color: '#ff9800', icon: 'üõ§Ô∏è', label: 'Estrada' },
        'danger': { color: '#b71c1c', icon: '‚öîÔ∏è', label: 'Perigo' },
        'poi': { color: '#d500f9', icon: '‚≠ê', label: 'Interesse' }
    };
    let currentTerrain = 'grass';

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }
    window.addEventListener('resize', resize);
    resize();

    const mapRef = ref(db, 'maps/' + MAP_ID);
    document.getElementById('loader').classList.add('active');
    
    onValue(mapRef, (snapshot) => {
        const data = snapshot.val();
        if (data) {
            if (data.config) {
                hexRadius = data.config.hexSize || 30;
                gridOpacity = data.config.gridOpacity !== undefined ? data.config.gridOpacity : 0.3;
                hexOpacity = data.config.hexOpacity !== undefined ? data.config.hexOpacity : 1.0;
                bgOpacity = data.config.bgOpacity !== undefined ? data.config.bgOpacity : 1.0;

                if (data.config.bgUrl && data.config.bgUrl !== bgImageUrl) {
                    bgImageUrl = data.config.bgUrl;
                    if(MODE === 'EDIT') document.getElementById('bgUrlInput').value = bgImageUrl;
                    loadImage(bgImageUrl);
                }
                if (MODE === 'EDIT') {
                    document.getElementById('hexSize').value = hexRadius;
                    document.getElementById('gridOpacity').value = gridOpacity;
                    document.getElementById('hexOpacity').value = hexOpacity;
                    document.getElementById('bgOpacity').value = bgOpacity;
                }
            }
            hexMap = data.hexes || {};
            borderMap = data.borders || {};
        }
        document.getElementById('loader').classList.remove('active');
        led.classList.add('on');
        draw();
    }, (err) => { alert("Erro ao carregar!"); console.error(err); });

    window.saveToCloud = () => {
        if (MODE === 'VIEW') return;
        led.className = 'status-led busy';
        update(ref(db, 'maps/' + MAP_ID), {
            config: {
                bgUrl: bgImageUrl,
                hexSize: parseInt(document.getElementById('hexSize').value),
                gridOpacity: parseFloat(document.getElementById('gridOpacity').value),
                hexOpacity: parseFloat(document.getElementById('hexOpacity').value),
                bgOpacity: parseFloat(document.getElementById('bgOpacity').value)
            },
            hexes: hexMap,
            borders: borderMap
        }).then(() => {
            led.className = 'status-led on';
            const btn = document.querySelector('.btn-save');
            const oldText = btn.innerText; btn.innerText = "‚úÖ SALVO!"; setTimeout(() => btn.innerText = oldText, 2000);
        }).catch(err => { alert("Erro: " + err); led.className = 'status-led'; });
    };

    window.updateBgFromUrl = (url) => { if(url) { bgImageUrl = url; loadImage(url); } };
    function loadImage(url) {
        const img = new Image(); img.crossOrigin = "Anonymous";
        img.onload = () => {
            bgImage = img;
            if (camera.x === 0 && camera.y === 0) { camera.x = canvas.width/2 - img.width/2; camera.y = canvas.height/2 - img.height/2; }
            draw();
        };
        img.src = url;
    }

    if (MODE === 'EDIT') {
        const paletteDiv = document.getElementById('palette');
        Object.keys(TERRAINS).forEach(key => {
            const t = TERRAINS[key];
            const div = document.createElement('div'); div.className = 'swatch'; div.innerHTML = `<span style="font-size:24px">${t.icon}</span>`; div.title = t.label;
            div.onclick = () => {
                currentTerrain = key;
                document.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
                div.classList.add('selected');
                if (activeTool !== 'generator') window.setTool('brush');
            };
            if(key === 'grass') div.classList.add('selected');
            paletteDiv.appendChild(div);
        });

        window.setTool = (tool) => {
            activeTool = tool;
            document.getElementById('btnBrush').classList.toggle('active', tool === 'brush');
            document.getElementById('btnHand').classList.toggle('active', tool === 'hand');
            document.getElementById('btnBorder').classList.toggle('active', tool === 'border');
            document.getElementById('btnGen').classList.toggle('active', tool === 'generator');
            
            document.getElementById('border-controls').classList.toggle('visible', tool === 'border');
            document.getElementById('gen-controls').classList.toggle('visible', tool === 'generator');
            
            canvas.style.cursor = tool === 'hand' ? 'grab' : (tool === 'generator' ? 'crosshair' : 'default');
        };

        window.clearHexes = () => { if(confirm('Limpar TUDO?')) { hexMap = {}; borderMap = {}; draw(); } };
        
        // Listeners para os sliders
        document.getElementById('hexSize').addEventListener('input', (e) => { hexRadius = parseInt(e.target.value); draw(); });
        document.getElementById('gridOpacity').addEventListener('input', (e) => { gridOpacity = parseFloat(e.target.value); draw(); });
        document.getElementById('hexOpacity').addEventListener('input', (e) => { hexOpacity = parseFloat(e.target.value); draw(); });
        document.getElementById('bgOpacity').addEventListener('input', (e) => { bgOpacity = parseFloat(e.target.value); draw(); });
    }

    // --- MATH ---
    function hexToPixel(q, r) { return { x: hexRadius * (3/2 * q), y: hexRadius * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r) }; }
    function pixelToHex(x, y) { return cubeRound((2/3 * x) / hexRadius, (-1/3 * x + Math.sqrt(3)/3 * y) / hexRadius); }
    function cubeRound(fracQ, fracR) {
        let fracS = -fracQ - fracR;
        let q = Math.round(fracQ); let r = Math.round(fracR); let s = Math.round(fracS);
        const qDiff = Math.abs(q - fracQ); const rDiff = Math.abs(r - fracR); const sDiff = Math.abs(s - fracS);
        if (qDiff > rDiff && qDiff > sDiff) q = -r - s; else if (rDiff > sDiff) r = -q - s; else s = -q - r;
        return { q, r };
    }
    function screenToWorld(sx, sy) { return { x: (sx - canvas.width / 2) / camera.zoom + camera.x, y: (sy - canvas.height / 2) / camera.zoom + camera.y }; }
    function hexDistance(a, b) { return (Math.abs(a.q - b.q) + Math.abs(a.q + a.r - b.q - b.r) + Math.abs(a.r - b.r)) / 2; }
    function getClosestSide(hexCenter, mouseWorld) {
        const dx = mouseWorld.x - hexCenter.x; const dy = mouseWorld.y - hexCenter.y;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI; if (angle < 0) angle += 360;
        return Math.floor(angle / 60);
    }

    // --- PROCEDURAL GENERATOR ---
    function generateBiome(centerQ, centerR) {
        const radius = parseInt(document.getElementById('genRadius').value);
        const density = parseInt(document.getElementById('genDensity').value) / 100;
        const mainType = currentTerrain;
        let mixType = 'grass';
        if (mainType === 'desert') mixType = 'mountain';
        if (mainType === 'snow') mixType = 'mountain';
        if (mainType === 'ocean') mixType = 'coast';

        for (let q = -radius; q <= radius; q++) {
            for (let r = Math.max(-radius, -q - radius); r <= Math.min(radius, -q + radius); r++) {
                const hex = { q: centerQ + q, r: centerR + r };
                const dist = hexDistance({q:centerQ, r:centerR}, hex);
                const key = `${hex.q},${hex.r}`;
                let chance = density; 
                if (dist > radius * 0.7) chance *= 0.6; 
                if (Math.random() < chance) {
                    let finalType = mainType;
                    const rand = Math.random();
                    if (rand < 0.05) finalType = 'ruin'; 
                    else if (rand < 0.15) finalType = mixType; 
                    if (mainType === 'void') delete hexMap[key];
                    else hexMap[key] = { type: finalType };
                }
            }
        }
        draw();
    }

    // --- DRAW ---
    function drawHex(ctx, x, y, size, color, icon) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle_rad = Math.PI / 180 * (60 * i);
            const px = x + size * Math.cos(angle_rad);
            const py = y + size * Math.sin(angle_rad);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        
        // Aplica opacidade apenas para o preenchimento (cor)
        if (color && color !== 'transparent') { 
            ctx.fillStyle = color; 
            ctx.fill(); 
        }
        
        // Grade (sempre desenhada se gridOpacity > 0, independente da opacidade do terreno)
        if (gridOpacity > 0) { 
            ctx.strokeStyle = `rgba(255,255,255,${gridOpacity})`; 
            ctx.lineWidth = 1; 
            ctx.stroke(); 
        }
        
        if (icon) {
            ctx.fillStyle = `rgba(255,255,255,${hexOpacity})`; // √çcone desvanece junto com terreno
            ctx.font = `${Math.floor(size/1.3)}px Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = "black"; ctx.shadowBlur = 4; ctx.fillText(icon, x, y); ctx.shadowBlur = 0;
        }
    }
    
    function drawBorderLine(ctx, x, y, size, side, color, width) {
        const a1 = Math.PI / 180 * (60 * side); const a2 = Math.PI / 180 * (60 * ((side + 1) % 6));
        const px1 = x + size * Math.cos(a1); const py1 = y + size * Math.sin(a1);
        const px2 = x + size * Math.cos(a2); const py2 = y + size * Math.sin(a2);
        ctx.beginPath(); ctx.moveTo(px1, py1); ctx.lineTo(px2, py2);
        ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap = 'round'; ctx.stroke();
    }

    function draw() {
        ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);

        // 1. Fundo (com opacidade)
        ctx.save();
        ctx.globalAlpha = bgOpacity;
        if (bgImage) ctx.drawImage(bgImage, -bgImage.width/2, -bgImage.height/2);
        else if (bgImageUrl) { ctx.fillStyle = "#555"; ctx.textAlign = "center"; ctx.fillText("Carregando Imagem...", 0, 0); }
        ctx.restore();

        // 2. Hex√°gonos (com opacidade global para o batch)
        ctx.save();
        ctx.globalAlpha = hexOpacity;
        for (let key in hexMap) {
            const [q, r] = key.split(',').map(Number);
            const pos = hexToPixel(q, r);
            const terrain = TERRAINS[hexMap[key].type];
            if (terrain) drawHex(ctx, pos.x, pos.y, hexRadius, terrain.color, terrain.icon);
        }
        ctx.restore();

        // 3. Fronteiras (n√£o afetadas pela opacidade do hex, para continuarem vis√≠veis)
        for (let key in borderMap) {
            const [q, r, s] = key.split(',').map(Number);
            const pos = hexToPixel(q, r);
            const b = borderMap[key];
            drawBorderLine(ctx, pos.x, pos.y, hexRadius, s, b.color, b.width);
        }

        // 4. Hover
        if (!isDragging && MODE === 'EDIT') {
            const mouseWorld = screenToWorld(lastMouse.x, lastMouse.y);
            const hex = pixelToHex(mouseWorld.x, mouseWorld.y);
            const center = hexToPixel(hex.q, hex.r);
            
            if (activeTool === 'border') {
                const side = getClosestSide(center, mouseWorld);
                const color = document.getElementById('borderColor').value;
                const width = document.getElementById('borderWidth').value;
                drawBorderLine(ctx, center.x, center.y, hexRadius, side, color, width);
            } else if (activeTool === 'generator') {
                const radius = parseInt(document.getElementById('genRadius').value);
                ctx.beginPath();
                ctx.arc(center.x, center.y, radius * hexRadius * 1.5, 0, 2*Math.PI);
                ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth = 2; ctx.stroke();
            } else if (activeTool === 'brush') {
                drawHex(ctx, center.x, center.y, hexRadius, 'rgba(255, 255, 255, 0.2)', null);
            }
        }
        ctx.restore();
    }

    function handleInput(screenX, screenY, isClick) {
        if (MODE === 'VIEW') return;
        const worldPos = screenToWorld(screenX, screenY);
        const hex = pixelToHex(worldPos.x, worldPos.y);
        const center = hexToPixel(hex.q, hex.r);
        const key = `${hex.q},${hex.r}`;
        
        if (activeTool === 'brush') {
            if (currentTerrain === 'void') delete hexMap[key];
            else hexMap[key] = { type: currentTerrain };
        } 
        else if (activeTool === 'border') {
            const side = getClosestSide(center, worldPos);
            const bKey = `${hex.q},${hex.r},${side}`;
            if (currentTerrain === 'void') delete borderMap[bKey];
            else borderMap[bKey] = { color: document.getElementById('borderColor').value, width: parseInt(document.getElementById('borderWidth').value) };
        }
        else if (activeTool === 'generator' && isClick) {
            generateBiome(hex.q, hex.r);
        }
        draw();
    }

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const mouseWorldBefore = screenToWorld(e.clientX, e.clientY);
        const newZoom = camera.zoom * (1 + -Math.sign(e.deltaY) * zoomIntensity);
        if (newZoom < 0.05 || newZoom > 10) return;
        camera.zoom = newZoom;
        const mouseWorldAfter = screenToWorld(e.clientX, e.clientY);
        camera.x += (mouseWorldBefore.x - mouseWorldAfter.x); camera.y += (mouseWorldBefore.y - mouseWorldAfter.y);
        draw();
    }, { passive: false });

    canvas.addEventListener('mousedown', (e) => {
        const isMiddle = e.button === 1; const isLeft = e.button === 0;
        if (activeTool === 'hand' || isSpacePressed || isMiddle) {
            isDragging = true; dragStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing';
        } else if (isLeft && MODE === 'EDIT') {
            handleInput(e.clientX, e.clientY, true); 
            if (activeTool !== 'generator') isDragging = true; 
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        lastMouse = { x: e.clientX, y: e.clientY };
        if (!isDragging) { if(MODE==='EDIT') draw(); return; }

        const isHandMode = (activeTool === 'hand' || isSpacePressed || e.buttons === 4);
        if (isHandMode) {
            const dx = (e.clientX - dragStart.x) / camera.zoom; const dy = (e.clientY - dragStart.y) / camera.zoom;
            camera.x -= dx; camera.y -= dy; dragStart = { x: e.clientX, y: e.clientY }; draw();
        } else if (MODE === 'EDIT') {
            handleInput(e.clientX, e.clientY, false);
        }
    });

    window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = (activeTool === 'hand' || isSpacePressed) ? 'grab' : (activeTool==='generator'?'crosshair':'default'); });
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !isSpacePressed) { isSpacePressed = true; canvas.style.cursor = 'grab'; }
        if (MODE === 'EDIT') {
            if (e.key.toLowerCase() === 'b') window.setTool('brush');
            if (e.key.toLowerCase() === 'h') window.setTool('hand');
            if (e.key.toLowerCase() === 'f') window.setTool('border');
            if (e.key.toLowerCase() === 'g') window.setTool('generator');
        }
    });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') { isSpacePressed = false; canvas.style.cursor = activeTool === 'hand' ? 'grab' : 'default'; isDragging = false; } });
    
    requestAnimationFrame(draw);
</script>
</body>
</html>
